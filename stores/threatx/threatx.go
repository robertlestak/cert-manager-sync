package threatx

import (
	"bytes"
	"cmp"
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"os"
	"strings"

	log "github.com/sirupsen/logrus"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/robertlestak/cert-manager-sync/pkg/state"
	"github.com/robertlestak/cert-manager-sync/pkg/tlssecret"
	"github.com/robertlestak/cert-manager-sync/stores"
)

type ThreatXStore struct {
	SecretName      string
	SecretNamespace string
	APIToken        string `json:"api_token"`
	CustomerName    string `json:"customer_name"`
	AuthToken       string `json:"auth_token"`
	Hostname        string `json:"hostname"`
}

type ThreatXSite struct {
	Hash                      int64           `json:"hash,omitempty"`
	Hostname                  string          `json:"hostname,omitempty"`
	Backend                   [][]interface{} `json:"backend,omitempty"`
	IsEnabled                 bool            `json:"isEnabled,omitempty"`
	RequestBlocking           bool            `json:"request_blocking,omitempty"`
	RiskBasedBlocking         bool            `json:"risk_based_blocking,omitempty"`
	ManualActionBlocking      bool            `json:"manual_action_blocking,omitempty"`
	StaticCachingEnabled      bool            `json:"static_caching_enabled,omitempty"`
	DynamicCachingEnabled     bool            `json:"dynamic_caching_enabled,omitempty"`
	SslEnabled                bool            `json:"ssl_enabled,omitempty"`
	SslBlob                   string          `json:"ssl_blob,omitempty"`
	SslExpTime                interface{}     `json:"ssl_exp_time,omitempty"`
	SslTerminateOnly          bool            `json:"ssl_terminate_only,omitempty"`
	OverrideResolve           interface{}     `json:"override_resolve,omitempty"`
	SslProtocols              interface{}     `json:"ssl_protocols,omitempty"`
	SslCiphers                interface{}     `json:"ssl_ciphers,omitempty"`
	SslRedirect               bool            `json:"ssl_redirect,omitempty"`
	AdvancedCaching           interface{}     `json:"advanced_caching,omitempty"`
	TimeCreated               int             `json:"time_created,omitempty"`
	CustomHTTPPort            int             `json:"custom_http_port,omitempty"`
	CustomHTTPSPort           int             `json:"custom_https_port,omitempty"`
	HTTP2Enabled              bool            `json:"http2_enabled,omitempty"`
	CustomResponseHeaders     interface{}     `json:"custom_response_headers,omitempty"`
	SetRealIPFrom             interface{}     `json:"set_real_ip_from,omitempty"`
	ClientMaxBodySize         interface{}     `json:"client_max_body_size,omitempty"`
	ProxyReadTimeout          interface{}     `json:"proxy_read_timeout,omitempty"`
	ProxySendTimeout          interface{}     `json:"proxy_send_timeout,omitempty"`
	WildcardSubdomainsEnabled bool            `json:"wildcard_subdomains_enabled,omitempty"`
}

type AutoGenerated struct {
	Ok ThreatXSite `json:"Ok"`
}

type ThreatXGetRequest struct {
	Command      string `json:"command"`
	Token        string `json:"token"`
	CustomerName string `json:"customer_name"`
	Name         string `json:"name"`
}

func (s *ThreatXStore) GetAPIKey(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"func":    "ThreatXStore.GetAPIKey",
		"context": ctx,
	})
	l.Debug("start")
	gopt := metav1.GetOptions{}
	sc, err := state.KubeClient.CoreV1().Secrets(s.SecretNamespace).Get(ctx, s.SecretName, gopt)
	if err != nil {
		return err
	}
	s.APIToken = string(sc.Data["api_token"])
	s.CustomerName = string(sc.Data["customer_name"])
	l.Debug("end")
	return nil
}

func threatxApiBase() string {
	return cmp.Or(os.Getenv("THREATX_API"), "https://provision.threatx.io/tx_api")
}

// ThreatxLogin retrieves the api token from k8s secret and then generates a short-term token against ThreatX API
func (s *ThreatXStore) ThreatxLogin(ctx context.Context) error {
	l := log.WithFields(log.Fields{
		"action": "ThreatxLogin",
	})
	l.Debug("start")
	var e error
	var r struct {
		Command  string `json:"command"`
		APIToken string `json:"api_token"`
		Token    string `json:"token"`
	}
	r.Command = "login"
	r.APIToken = s.APIToken
	jd, jerr := json.Marshal(r)
	if jerr != nil {
		l.Error(jerr)
		return jerr
	}
	l.Debugf("request=%s", string(jd))
	c := &http.Client{}
	req, err := http.NewRequest("POST", threatxApiBase()+"/v1/login", bytes.NewBuffer(jd))
	if err != nil {
		l.Error(err)
		return err
	}
	resp, err := c.Do(req)
	if err != nil {
		l.Error(err)
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		l.Error(err)
		return err
	}
	bd, berr := io.ReadAll(resp.Body)
	if berr != nil {
		l.Error(berr)
		return berr
	}
	l.Debugf("response=%s", string(bd))
	type Resp struct {
		Ok struct {
			Token  string `json:"token"`
			Status bool   `json:"status"`
		} `json:"Ok"`
	}
	var rr *Resp
	jerr = json.Unmarshal(bd, &rr)
	if jerr != nil {
		l.Error(jerr)
		return jerr
	}
	s.AuthToken = rr.Ok.Token
	l.Debugf("auth_token=%s", s.AuthToken)
	return e
}

// Get retrieves a single ThreatX site from the API
func (s *ThreatXStore) GetSite(ctx context.Context) (ThreatXSite, error) {
	l := log.WithFields(log.Fields{
		"func": "ThreatXStore.GetSite",
	})
	l.Debug("start")
	var e error
	var tx ThreatXSite
	if s.AuthToken == "" {
		l.Error("auth_token is empty")
		return tx, errors.New("auth_token is empty")
	}
	tgr := ThreatXGetRequest{
		Command:      "get",
		Token:        s.AuthToken,
		CustomerName: s.CustomerName,
		Name:         s.Hostname,
	}
	jd, jerr := json.Marshal(tgr)
	if jerr != nil {
		l.Error(jerr)
		return tx, jerr
	}
	l.Debugf("request=%s", string(jd))
	c := &http.Client{}
	req, err := http.NewRequest("POST", threatxApiBase()+"/v2/sites", bytes.NewBuffer(jd))
	if err != nil {
		l.Error(err)
		return tx, err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	resp, err := c.Do(req)
	if err != nil {
		l.Error(err)
		return tx, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		l.Error(err)
		return tx, err
	}
	type Resp struct {
		Ok ThreatXSite `json:"Ok"`
	}
	var rr Resp
	bd, berr := io.ReadAll(resp.Body)
	if berr != nil {
		l.Error(berr)
		return tx, berr
	}
	l.Debugf("response=%s", string(bd))
	jerr = json.Unmarshal(bd, &rr)
	if jerr != nil {
		l.Error(jerr)
		return tx, jerr
	}
	l.Debugf("site=%v", rr.Ok)
	return rr.Ok, e
}

// Update updates a single ThreatX site
func (s *ThreatXStore) UpdateSite(ctx context.Context, tx ThreatXSite) error {
	l := log.WithFields(log.Fields{
		"func": "ThreatXStore.UpdateSite",
	})
	l.Debug("start")
	if s.AuthToken == "" {
		l.Error("auth_token is empty")
		return errors.New("auth_token is empty")
	}
	type TReq struct {
		Command      string      `json:"command"`
		Token        string      `json:"token"`
		CustomerName string      `json:"customer_name"`
		Name         string      `json:"name"`
		ThreatXSite  ThreatXSite `json:"site"`
	}
	r := &TReq{
		Command:      "update",
		Token:        s.AuthToken,
		CustomerName: s.CustomerName,
		Name:         s.Hostname,
		ThreatXSite:  tx,
	}
	jd, jerr := json.Marshal(r)
	if jerr != nil {
		l.Error(jerr)
		return jerr
	}
	l.Debugf("request=%s", string(jd))
	c := &http.Client{}
	req, err := http.NewRequest("POST", threatxApiBase()+"/v2/sites", bytes.NewBuffer(jd))
	if err != nil {
		l.Error(err)
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := c.Do(req)
	if err != nil {
		l.Error(err)
		return err
	}
	defer resp.Body.Close()
	bd, berr := io.ReadAll(resp.Body)
	if berr != nil {
		l.Error(berr)
		return berr
	}
	if resp.StatusCode != 200 {
		l.Errorf("response=%d", resp.StatusCode)
		l.Errorf("response_body=%s", bd)

		return err
	}
	l.Debugf("response=%s", string(bd))
	return nil
}

func New(c tlssecret.GenericSecretSyncConfig) (stores.RemoteStore, error) {
	s := &ThreatXStore{}
	if c.Config["secret-name"] != "" {
		s.SecretName = c.Config["secret-name"]
	}
	if c.Config["secret-namespace"] != "" {
		s.SecretNamespace = c.Config["secret-namespace"]
	}
	// if secret name is in the format of "namespace/secretname" then parse it
	if strings.Contains(s.SecretName, "/") {
		if parts := strings.Split(s.SecretName, "/"); len(parts) == 2 {
			s.SecretNamespace = parts[0]
			s.SecretName = parts[1]
		}
	}
	if s.SecretName == "" {
		return nil, stores.ErrSecretNameNotFound
	}
	if s.SecretNamespace == "" {
		return nil, stores.ErrSecretNamespaceNotFound
	}
	if c.Config["hostname"] != "" {
		s.Hostname = c.Config["hostname"]
	}

	return s, nil
}

func (s *ThreatXStore) Sync(c *tlssecret.Certificate) (map[string]string, error) {
	s.SecretNamespace = c.Namespace
	l := log.WithFields(log.Fields{
		"action":          "Sync",
		"store":           "threatx",
		"secretName":      s.SecretName,
		"secretNamespace": s.SecretNamespace,
	})
	l.Debug("start")
	l = l.WithFields(log.Fields{
		"id": s.Hostname,
	})
	ctx := context.Background()
	if err := s.GetAPIKey(ctx); err != nil {
		l.Error(err)
		return nil, err
	}
	if err := s.ThreatxLogin(ctx); err != nil {
		l.Error(err)
		return nil, err
	}
	site, err := s.GetSite(ctx)
	if err != nil {
		l.Error(err)
		return nil, err
	}
	site.SslBlob = string(c.FullChain()) + string(c.Key)
	site.SslEnabled = true
	if err := s.UpdateSite(ctx, site); err != nil {
		l.WithError(err).Error("sync error")
		return nil, err
	}
	l.Info("certificate synced")
	return nil, nil
}

func init() {
	stores.Register("threatx", stores.StoreCreatorFunc(New))
}
